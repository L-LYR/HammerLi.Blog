---
Author: HammerLi
Date: 2021.3.19
Tag: [Algorithm][DP][Bitmasking]
---

[TOC]

# 状态压缩动态规划

状态压缩动态规划是通过将状态压缩为整数来达到优化转移目的的一种动态规划。

本方法用于程序或者算法设计中需要保存复杂的状态的情况，比如集合等。状态压缩所提供的一方面是数据存储空间的压缩，另一方面则是状态之间比较时的开销更小。因为该方法常常用基本数据类型来压缩状态，所以局限于基本数据类型的字长。题目中大概率会有一维的数据很小。

主要的思路其实比较简单。首先是确定状态的描述，比如某一行的排列情况。接着是找状态之间的转换关系，一般在场景描述中指出或者隐含，比如行与行之间的关系。状态间的转换可以使用搜索（常用 DFS ）来获得，结果一般来说是一个映射或者状态转移矩阵。最后要么是求最值，要么是根据状态转移矩阵求符合题意的转移方案数。

## 常用的位运算

```c++
// 判断x的第i位上是否是1
(x >> i) & 1;
// x的第i位置1
x | (1 << i);
// x的第i位反转
x ^ (1 << i);
// x的右侧第一个1置零
x & (x - 1);
```

## 例题

### [互不侵犯](https://vjudge.net/problem/LibreOJ-2153)

确认一个国王的位置需要知道行号和列号，所以递推势必要使用至少两个 `for` 循环来完成。当我们从第 i 行向 i + 1 行递推时，需要考虑上一行的状态，因此我们要使用一个 `int` 类型来保存每一行的分配情况。

因此，考虑如下状态转移：
$$
f(r, s, j) = \sum f(r - 1, t, j - s.count)
$$
$f(r, s, j)$表示对于第 r 行状态为 s 时已经填满了 j 个国王的方案数，s.count 表示状态 s 共填了多少国王。状态 s 是使用 n 位的二进制来表示当前行上国王的位置情况。

为了满足题意，相邻两行的状态 s 和 t 必须满足如下条件：

```c++
(s & t == 0) and ((s << 1) & t == 0) and (s & (t << 1));
```

最终答案为：
$$
ans = \sum f(n, s, k)
$$

### [炮兵阵地](https://vjudge.net/problem/LibreOJ-10173)

方法和上述类似，不过为了更好地判断，这里将地图按行压缩，存成 int 数组，方便判断状态是否非法。

转移方程如下：
$$
f(i, s, t) = \max(f(i, s, t), f(i - 1, t, k) + s.count)
$$
条件：

```c++
(s & g[i] != 0) and (t & g[i - 1] != 0) and (s & t != 0) and (k & g[i - 2] != 0) and (s & k != 0) and (t & k != 0);
```

最终答案为：
$$
ans = \max{f(n, s, t)}
$$

### TODO:TSP

